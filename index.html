<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Minecraft Block Globe - Working</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>

<script>
  // Basic scene setup
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 35);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls for orbiting
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 2); // soft white light
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
  directionalLight.position.set(20, 30, 20);
  scene.add(directionalLight);

  // Group for cubes
  const globeGroup = new THREE.Group();
  scene.add(globeGroup);

  // Cube parameters
  const cubeSize = 1;
  const radius = 10;

  // Helper function: spherical to cartesian
  function sphericalToCartesian(radius, theta, phi) {
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.cos(phi);
    const z = radius * Math.sin(phi) * Math.sin(theta);
    return new THREE.Vector3(x, y, z);
  }

  // Create cubes on sphere surface
  const step = 0.3; // adjust for density

  const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

  for(let phi = 0; phi <= Math.PI; phi += step) {
    for(let theta = 0; theta < 2 * Math.PI; theta += step) {
      const pos = sphericalToCartesian(radius, theta, phi);

      // Color logic based on latitude (phi)
      const latRatio = phi / Math.PI;

      let colorHex;
      if(latRatio < 0.25 || latRatio > 0.75) {
        colorHex = 0x3b82f6; // blue water
      } else if(latRatio > 0.45 && latRatio < 0.55) {
        colorHex = 0x92400e; // brown dirt
      } else {
        colorHex = 0x22c55e; // green land
      }

      const material = new THREE.MeshStandardMaterial({color: colorHex});
      const cube = new THREE.Mesh(geometry, material);

      cube.position.copy(pos);

      // Make cube face outwards (optional)
      cube.lookAt(new THREE.Vector3(0,0,0));
      cube.rotateX(Math.PI);

      globeGroup.add(cube);
    }
  }

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    globeGroup.rotation.y += 0.004;
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>
